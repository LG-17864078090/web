<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="oprateSystem.css">
</head>
<body>
<div id="app" class="wrapper">
    <h1 class="title">操作系统模拟</h1>
    <div class="allProcess">
        <div class="menu-container">
            <span>请输入名称:</span>
            <input type="text" v-model="processName">
            <span>大小:</span>
            <input type="text" v-model="processSize">
            <h2 class="menu-item" @click="creat">创建进程</h2>
            <h2 class="menu-item" @click="timeUp">时间片到</h2>
            <h2 class="menu-item" @click="block">进程阻塞</h2>
            <h2 class="menu-item" @click="weakUp">唤醒进程</h2>
            <h2 class="menu-item" @click="endUp">结束进程</h2>
            <h2 class="menu-item requestDevice" @click="requestDevice">申请设备</h2>
            <h2 class="menu-item releaseDevice" @click="releaseDevice">释放设备</h2>
        </div>

        <div class="showMsg">
            <h2 class="msgTitle">队列信息</h2>
            <div class="showMsg-queue">
                <div class="showMsg-ready">
                    <h3>---就绪队列--- </h3>
                    <li v-for="val in ready">
                        <span>{{val.name}}</span>
                        <span>size:{{val.size}}</span>
                    </li>
                </div>
                <div class="showMsg-blocked">
                    <h3>---阻塞队列--- </h3>
                    <li v-for="val in blocked">
                        <span>{{val.name}}</span>
                        <span>size:{{val.size}}</span>
                    </li>
                </div>
                <div class="showMsg-running">
                    <h3>---运行队列---</h3>
                    <li v-for="val in running">
                        <span>{{val.name}}</span>
                        <span>size:{{val.size}}</span>
                    </li>
                </div>
            </div>
        </div>
    </div>
    <div class="showMemoryDetail">
        <button @click=(memoryIsShow=!memoryIsShow)>位示图</button>
        <div class="pageExcel" v-if="memoryIsShow">
            <h3>页表</h3>
            <table>
                <thead>
                    <tr><th>页号</th><th>块号</th><th>交换空间</th><th>存在位</th></tr>
                </thead>
                <tbody v-for="val in running">
                    <tr v-for="page in val.page">
                        <td>{{page.page}}</td>
                        <td>{{page.piece}}</td>
                        <td>{{page.swap}}</td>
                        <td>{{page.exist}}</td>
                    </tr>
                </tbody>
            </table>
            <input type="text" v-model="callSwapPage">
            <button @click="FIFO">SWAP</button>
            <h4 class="pageFaultRate">缺页率: {{this.inSwap}} / {{this.inSwap+this.inMemory}}</h4>
        </div>

        <div class="memory" v-if="memoryIsShow">
            <div class="memoryMap">
                <h3>内存位示图</h3>
                <span v-for="val in memory">{{val}}</span>
            </div>
        </div>

        <div class="swap" v-if="memoryIsShow">
            <div class="swapSpace">
                <h3>交换空间</h3>
                <span v-for="val in swapSpace">{{val}}</span>
            </div>
        </div>
    </div>
    <div class="IOdevice">
        <div class="showDevice">
            <div class="channel">
                <li v-for="val in channel">
                    <h4 class="id">
                        {{val.id}}
                    </h4>
                    <div class="detail">
                        <p>是否空闲: {{val.isFree}}</p>
                        <p>占用进程: {{val.process}}</p>
                        <p>
                            等待队列:<span v-for="wait in val.waiting">{{wait.name}} </span>
                        </p>
                    </div>

                </li>
            </div>
            <div class="control">
                <li v-for="val in control">
                    <h4 class="id">
                        {{val.id}}
                    </h4>
                    <div class="detail">
                        <p>是否空闲: {{val.isFree}}</p>
                        <p>占用进程: {{val.process}}</p>
                        <p>上级: {{val.channel.id}}</p>
                        <p>
                            等待队列:<span v-for="wait in val.waiting">{{wait.name}} </span>
                        </p>
                    </div>
                </li>
            </div>
            <div class="device">
                <li v-for="val in device">
                    <h4 class="id">
                        {{val.id}}
                    </h4>
                    <div class="detail">
                        <p>是否空闲:{{val.isFree}}</p>
                        <p>占用进程:{{val.process}}</p>
                        <p>上级:{{val.control.id}}</p>
                        <p>
                            等待队列:<span v-for="wait in val.waiting">{{wait.name}} </span>
                        </p>
                    </div>
                </li>
            </div>
        </div>
        <div class="oprateDevice">
            <span>ID:</span><input type="text" v-model="DCCid">
            <span>上级:</span><input type="text" v-model="DCparent">
            <button @click="addChannel">添加通道</button>
            <button @click="delChannel">删除通道</button>
            <button @click="addControl">添加控制器</button>
            <button @click="delControl">删除控制器</button>
            <button @click="addDevice">添加设备</button>
            <button @click="delDevice">删除设备</button>
        </div>
    </div>
</div>

<script src="vue.js"></script>
<script>
    //进程数据结构
    class PCB {
        constructor(name,size){
            this.name=name;
            this.size=size;
            this.page=[];
        }
    }

    //页表数据结构
    class PAGE{
        constructor(page,piece,swap,exist){
            this.page=page;
            this.piece=piece;
            this.swap=swap;
            this.exist=exist;
        }
    }

    //通道数据结构
    class CHANNEL{
        constructor(id){
            this.id=id;
            this.isFree=true;
            this.process='';
            this.waiting=[];
        }
    }

    //控制器数据结构
    class CONTROL{
        constructor(id,CHANNEL){
            this.id=id;
            this.isFree=true;
            this.process='';
            this.waiting=[];
            this.channel=CHANNEL;
        }
    }

    //设备数据结构
    class DEVICE{
        constructor(id,CONTROL){
            this.id=id;
            this.isFree=true;
            this.process='';
            this.waiting=[];
            this.control=CONTROL;
        }
    }

    var vm = new Vue({
        el:'#app',
        data:{
            processName:'',//进程名称
            processSize:'',//进程大小
            DCCid:'',//设备控制器通道ID
            DCparent:'',//设备通道父级ID
            callSwapPage:'',//物理地址
            memoryIsShow:false,//位示图显示开关
            inMemory:0,//记录所访问块在内存次数
            inSwap:0,//记录所访问块在交换空间次数
            physicalMemory:3,//可用内存块大小
            ready:[],//就绪队列
            blocked:[],//阻塞队列
            running:[],//运行队列
            memory:[],//内存位示图
            swapSpace:[],//交换空间位示图
            channel:[],//通道
            control:[],//控制器
            device:[]//设备
        },
        //钩子函数
        created(){
            this.creatMap();
            this.creatSwapSpace();
            this.creatDCC();
        },
        methods:{
            //判断进程输入框内容是否在某队列
            findProcess(arr,temp){
                let flag = true;
                for(let index=0;index<arr.length;index++){
                    if(temp==arr[index].name){
                        flag=false;
                    }
                }
                return flag;
            },

            //通过ID判断DCC是否存在
            findDCCById(ID,arr){
                let flag = false;
                for(let i=0;i<arr.length;i++){
                    if(arr[i].id==ID){
                       flag=true;
                    }
                }
                return flag;
            },

            //生成随机内存
            creatMap(){
                for(let i=0;i<64;i++){
                    this.memory[i] = Math.floor(Math.random() * 2);
                }
            },

            //生成随机交换空间
            creatSwapSpace(){
                for(let i=0;i<128;i++){
                    this.swapSpace[i] = Math.floor(Math.random() * 2);
                }
            },

            //初始化设备，控制器，通道
            creatDCC(){
                var channel_1 = new CHANNEL('通道1');
                var channel_2 = new CHANNEL('通道2');
                var control_1 = new CONTROL('控制器1',channel_1);
                var control_2 = new CONTROL('控制器2',channel_1);
                var control_3 = new CONTROL('控制器3',channel_2);
                var device_1 = new DEVICE('设备1',control_1);
                var device_2 = new DEVICE('设备2',control_1);
                var device_3 = new DEVICE('设备3',control_2);
                var device_4 = new DEVICE('设备4',control_2);
                var device_5 = new DEVICE('设备5',control_3);
                this.channel.push(channel_1);
                this.channel.push(channel_2);
                this.control.push(control_1);
                this.control.push(control_2);
                this.control.push(control_3);
                this.device.push(device_1);
                this.device.push(device_2);
                this.device.push(device_3);
                this.device.push(device_4);
                this.device.push(device_5);
            },

            //进程存入内存与交换空间
            saveToMemory(PCB,memoryMap,swapSpaceMap,physicalMemory){
                if(PCB.page.length==0){
                    //计算进程所需内存块数
                    let pageCount = Math.ceil(PCB.size/1024);
                    if(pageCount<physicalMemory){
                        //小于三块直接存入内存
                        for(let i=0;i<pageCount;i++){
                            for(let j=0;j<64;j++){
                                if(memoryMap[j]==0){
                                    memoryMap[j]=11;
                                    let PageTemp = new PAGE(i,j,-1,1);
                                    PCB.page[i]=PageTemp;
                                    j=64;
                                }
                            }
                        }
                    }else{
                        //大于三块前三位存进物理内存
                        for(let i=0;i<physicalMemory;i++){
                            for(let j=0;j<64;j++){
                                if(memoryMap[j]==0){
                                    memoryMap[j]=11;
                                    let PageTemp = new PAGE(i,j,-1,1);
                                    PCB.page[i]=PageTemp;
                                    j=64;
                                }
                            }
                        }
                        //后面的存入交换空间
                        for(let i=physicalMemory;i<pageCount;i++){
                            for(let j=0;j<128;j++){
                                if(swapSpaceMap[j]==0){
                                    swapSpaceMap[j]=11;
                                    let PageTemp = new PAGE(i,-1,j,0);
                                    PCB.page[i]=PageTemp;
                                    j=128;
                                }
                            }
                        }
                    }
                }


            },

            //内存与交换空间释放
            releaseMemory(PCB,memoryMap,swapSpaceMap,physicalMemory){
                let pageCount = PCB.page.length;
                if(pageCount<physicalMemory){
                    for(let i=0;i<PCB.page.length;i++){
                        memoryMap[PCB.page[i].piece]=0;
                    }
                    PCB.page=[];
                }else{
                    for(let i=0;i<physicalMemory;i++){
                        memoryMap[PCB.page[i].piece]=0;
                    }
                    for(let i=physicalMemory;i<pageCount;i++) {
                        swapSpaceMap[PCB.page[i].swap]=0;
                    }
                    PCB.page=[];
                }

            },

            //重置缺页率
            resetPageFaultRate(){
                this.inSwap=0;
                this.inMemory=0;
                this.callSwapPage='';
            },

            //(先进先出FIFO算法)内存与交换空间交换内容
            FIFO(){
                if(this.running.length){
                    let callSwapPageIndex=0;
                    for(let i=0;i<this.running[0].page.length;i++){
                        if(this.running[0].page[i].page==Math.floor(this.callSwapPage*1/1024)){
                            callSwapPageIndex=i;//获取所输入逻辑地址对应的物理地址块在页表数组中的下标
                        }
                    }

                    if(callSwapPageIndex>=this.physicalMemory){
                        let tempArr = this.running[0].page;
                        this.running[0].page=[];

                        let tempPage1=tempArr[0];//最先进入内存的页
                        let tempPage2=tempArr[callSwapPageIndex];//需要进入内存的页

                        tempArr[0]=new PAGE(tempArr[0].page,tempPage2.piece,tempPage2.swap,tempPage2.exist);
                        tempArr[callSwapPageIndex]=new PAGE(tempArr[callSwapPageIndex].page,tempPage1.piece,tempPage1.swap,tempPage1.exist);

                        tempPage1=tempArr[0];
                        tempPage2=tempArr[callSwapPageIndex];

                        for(let i=0;i<this.physicalMemory-1;i++){
                            tempArr[i]=new PAGE(tempArr[i+1].page,tempArr[i+1].piece,tempArr[i+1].swap,tempArr[i+1].exist);
                        }
                        tempArr[this.physicalMemory-1]=new PAGE(tempPage2.page,tempPage2.piece,tempPage2.swap,tempPage2.exist);
                        tempArr[callSwapPageIndex]=new PAGE(tempPage1.page,tempPage1.piece,tempPage1.swap,tempPage1.exist);

                        this.running[0].page=tempArr;
                        tempArr=[];

                        this.inSwap++;
                    }else if(callSwapPageIndex>=0||callSwapPageIndex<this.physicalMemory){
                        this.inMemory++;
                    }

                }else{
                    alert("无进程块可交换")
                }

            },

            //添加设备
            addDevice(){
                let flag = this.findDCCById(this.DCCid,this.device);
                if(flag){
                    alert('该设备ID已存在');
                }else if(this.DCparent==''){
                    alert('父级控制器不能为空');
                }else if(!this.findDCCById(this.DCparent,this.control)){
                    alert('该父级控制器不存在');
                }else{
                    for(let i=0;i<this.control.length;i++){
                        if(this.control[i].id==this.DCparent){
                            let tmpDevice = new DEVICE(this.DCCid,this.control[i]);
                            this.device.push(tmpDevice);
                        }
                    }
                }
            },

            //删除设备
            delDevice(){
                let flag = this.findDCCById(this.DCCid,this.device);
                if(flag){
                    for(let i=0;i<this.device.length;i++){
                        if(this.device[i].id==this.DCCid){
                            this.device.splice(i,1);
                        }
                    }
                }else{
                    alert('该设备ID不存在');
                }

            },

            //添加控制器
            addControl(){
                let flag = this.findDCCById(this.DCCid,this.control);
                if(flag){
                    alert('该控制器ID已存在');
                }else if(this.DCparent==''){
                    alert('父级通道不能为空');
                }else if(!this.findDCCById(this.DCparent,this.channel)){
                    alert('该父级通道不存在');
                }else {
                    for (let i = 0; i < this.channel.length; i++) {
                        if (this.channel[i].id == this.DCparent) {
                            let tmpControl = new CONTROL(this.DCCid, this.channel[i]);
                            this.control.push(tmpControl);
                        }
                    }
                }
            },

            //删除控制器
            delControl(){
                if(this.findDCCById(this.DCCid,this.control)){
                    let flag = false;
                    for(let i=0;i<this.device.length;i++){
                        if(this.device[i].control.id==this.DCCid){
                            flag=true;
                        }
                    }
                    if(flag){
                        alert('该控制器有设备相连接，不可删除')
                    }else{
                        for(let i=0;i<this.control.length;i++){
                            if(this.control[i].id==this.DCCid){
                                this.control.splice(i,1);
                            }
                        }
                    }
                }else{
                    alert('该控制器ID不存在')
                }
            },

            //添加通道
            addChannel(){
                let flag = this.findDCCById(this.DCCid,this.channel);
                if(flag){
                    alert('该通道ID已存在');
                }else{
                    let tmpChannel = new CHANNEL(this.DCCid);
                    this.channel.push(tmpChannel);
                }
            },

            //删除通道
            delChannel(){
                if(this.findDCCById(this.DCCid,this.channel)){
                    let flag = false;
                    for(let i=0;i<this.control.length;i++){
                        if(this.control[i].channel.id==this.DCCid){
                            flag=true;
                        }
                    }
                    if(flag){
                        alert('该通道有控制器相连接，不可删除')
                    }else{
                        for(let i=0;i<this.channel.length;i++){
                            if(this.channel[i].id==this.DCCid){
                                this.channel.splice(i,1);
                            }
                        }
                    }
                }else{
                    alert('该通道ID不存在')
                }
            },

            //申请设备
            requestDevice(){
                if(this.running.length){
                    let tmpID = prompt("请输入设备ID:",'');
                    let flag = this.findDCCById(tmpID,this.device);
                    if(flag){
                        let tmpIndex=0;
                        for(let i=0;i<this.device.length;i++){
                            if(this.device[i].id==tmpID){
                                tmpIndex=i;
                            }
                        }
                        if(this.device[tmpIndex].isFree){
                            this.device[tmpIndex].isFree=!this.device[tmpIndex].isFree;
                            this.device[tmpIndex].process=this.running[0].name;
                            alert('成功申请'+this.device[tmpIndex].id);

                            for(let i=0;i<this.control.length;i++){
                                if(this.control[i].id==this.device[tmpIndex].control.id){
                                    //调用申请控制器函数
                                    this.requestControl(this.running[0],this.control[i]);
                                }
                            }
                        }else if(this.device[tmpIndex].process==this.running[0].name){
                            alert(this.device[tmpIndex].id+'正在被进程'+this.running[0].name+'使用');
                        }else{
                            alert(this.device[tmpIndex].id+'已被占用，已将进程'+this.running[0].name+'插入改设备等待队列');
                            this.device[tmpIndex].waiting.push(this.running[0]);
                        }
                    }else{
                        alert("该设备ID不存在")
                    }
                }else{
                    alert('无运行进程')
                }
            },

            //释放设备
            releaseDevice(){
                if(this.running.length){
                    let tmpID = prompt("请输入设备ID:",'');
                    let flag = this.findDCCById(tmpID,this.device);
                    if(flag){
                        let tmpIndex=0;
                        for(let i=0;i<this.device.length;i++){
                            if(this.device[i].id==tmpID){
                                tmpIndex=i;
                            }
                        }
                        if(this.device[tmpIndex].process==this.running[0].name){
                            let PCBName = this.device[tmpIndex].process;
                            if(this.device[tmpIndex].waiting.length){
                                this.device[tmpIndex].process=this.device[tmpIndex].waiting[0].name;
                                let tmpProcess = this.device[tmpIndex].waiting[0];
                                this.device[tmpIndex].waiting.splice(0,1);
                                this.requestControl(tmpProcess,this.device[tmpIndex].control);
                            }else{
                                this.device[tmpIndex].isFree=true;
                                this.device[tmpIndex].process='';
                                alert('进程'+PCBName+'已释放'+this.device[tmpIndex].id);
                            }
                            this.releaseControl(PCBName,this.device[tmpIndex].control);
                        }else{
                            alert('运行进程未占用该设备');
                        }
                    }else{
                        alert('该设备ID不存在')
                    }
                }
            },

            //申请控制器
            requestControl(PCB,Control){
                if(Control.isFree){
                    Control.isFree=false;
                    Control.process=PCB.name;
                    alert('成功申请'+Control.id);
                    this.requestChannel(PCB,Control.channel);

                }else if(Control.process==PCB.name){
                    alert(Control.id+'正在被进程'+PCB.name+'使用');
                    this.requestChannel(PCB,Control.channel);
                }else{
                    alert(Control.id+'已被占用，已将进程'+PCB.name+'加入该控制器的等待队列');
                    Control.waiting.push(PCB);
                }
            },

            //释放控制器
            releaseControl(PCBName,Control){
                if(Control.process==PCBName){
                    PCBName=Control.process;
                    if(Control.waiting.length){
                        Control.process=Control.waiting[0].name;
                        let tmpProcess=Control.waiting[0];
                        Control.waiting.splice(0,1);
                        this.requestChannel(tmpProcess,Control.channel);
                    }else{
                        Control.isFree=true;
                        Control.process='';
                        alert('进程'+PCBName+'已释放'+Control.id);
                    }
                    this.releaseChannel(PCBName,Control.channel);
                }else{
                    alert('运行进程未占用'+Control.id);
                }
            },

            //申请通道
            requestChannel(PCB,Channel){
                if(Channel.isFree){
                    Channel.isFree=false;
                    Channel.process=PCB.name;
                    alert('成功申请'+Channel.id);
                }else if(Channel.process==PCB.name){
                    alert(Channel.id+'正在被进程'+PCB.name+'使用');
                }else{
                    alert(Channel.id+'已被占用，已将进程'+PCB.name+'加入该通道的等待队列');
                    Channel.waiting.push(PCB);
                }
            },

            //释放通道
            releaseChannel(PCBName,Channel){
                if(Channel.process==PCBName){
                    if(Channel.waiting.length){
                        Channel.process=Channel.waiting[0].name;
                        Channel.waiting.splice(0,1);
                    }else{
                        Channel.isFree=true;
                        Channel.process='';
                        alert('进程'+PCBName+'已释放'+Channel.id);
                    }

                }else{
                    alert('运行进程未占用'+Channel.id);
                }

            },

            //创建进程
            creat(){
               if(this.processName){
                   let flag=this.findProcess(this.ready,this.processName)&&this.findProcess(this.blocked,this.processName)&&this.findProcess(this.running,this.processName);
                   if (flag) {
                       let PCBTemp = new PCB(this.processName,this.processSize*1);
                       this.ready.push(PCBTemp);
                       this.processName = '';
                       this.processSize = '';
                       if(this.running.length==0){
                           this.running.push(this.ready[0]);
                           this.saveToMemory(this.running[0],this.memory,this.swapSpace,this.physicalMemory);
                           this.ready.splice(0,1);
                       }
                       this.resetPageFaultRate();
                   }else{
                       alert('该名称的进程已存在！')
                   }

               }else{
                   alert('进程名称不能为空！')
               }
            },

            //时间片到
            timeUp() {
                if(this.running.length!=0){
                    this.ready.push(this.running[0]);
                    //this.releaseMemory(this.running[0],this.memory,this.swapSpace,this.physicalMemory);
                    this.running[0] = this.ready[0];
                    this.saveToMemory(this.running[0],this.memory,this.swapSpace,this.physicalMemory);
                    this.ready.splice(0, 1);
                    this.resetPageFaultRate();
                }
            },

            //进程阻塞
            block(){
                this.blocked.push(this.running[0]);
                //this.releaseMemory(this.running[0],this.memory,this.swapSpace,this.physicalMemory);
                //判断就绪队列是否还有进程
                if(this.ready.length!=0){
                    this.running[0]=this.ready[0];
                    this.saveToMemory(this.running[0],this.memory,this.swapSpace,this.physicalMemory);
                    this.ready.splice(0,1);
                }else{
                    this.running.splice(0,1);
                    alert("无就绪进程,该操作会使CPU空闲")
                }
                this.resetPageFaultRate();
            },

            //唤醒进程
            weakUp(){
                let flag=this.findProcess(this.blocked,this.processName);
                if(flag){
                    alert('该进程不在阻塞队列,无法唤醒')
                }else{
                    let tempIndex;
                    for(let index=0;index<this.blocked.length;index++){
                        if(this.processName==this.blocked[index].name){
                            tempIndex=index;
                        }
                    }
                    this.ready.push(this.blocked[tempIndex]);
                    this.blocked.splice(tempIndex,1);
                    this.processName = '';
                    this.processSize = '';

                    //如果运行队列为空，把就绪首个进程添加到运行队列
                    if(this.running.length==0){
                        this.running.push(this.ready[0]);
                        this.saveToMemory(this.running[0],this.memory,this.swapSpace,this.physicalMemory);
                        this.ready.splice(0,1);
                        this.resetPageFaultRate();
                    }
               }
            },

            //结束进程
            endUp(){
                if(this.running.length!=0){
                    this.releaseMemory(this.running[0],this.memory,this.swapSpace,this.physicalMemory);
                    if(this.ready.length!=0){
                        this.running[0]=this.ready[0];
                        this.saveToMemory(this.running[0],this.memory,this.swapSpace,this.physicalMemory);
                        this.ready.splice(0,1);
                    }else{
                        this.running.splice(0,1);
                        alert("无就绪进程,该操作会使CPU空闲")
                    }
                    this.resetPageFaultRate();
                }else{
                    alert("无运行进程")
                }
            }
        }
    })
    
</script>
</body>
</html>